海龟系统改进后的策略源码[开拓者公式]

Params
   Numeric RiskRatio(1);                   // % Risk Per N ( 0 - 100)
   Numeric ATRLength(20);                  // 平均波动周期 ATR Length
   Numeric boLength(20);                   // 短周期 BreakOut Length
   Numeric fsLength(55);                   // 长周期 FailSafe Length
   Numeric teLength(10);                   // 离市周期 Trailing Exit Length
   Bool LastProfitableTradeFilter(True);   // 使用入市过滤条件
Vars
       Numeric MinPoint;                       // 最小变动单位
       NumericSeries AvgTR;                                        // ATR
   Numeric N;                              // N 值
   Numeric TotalEquity;                    // 按最新收盘价计算出的总资产
   Numeric TurtleUnits;                    // 交易单位
   NumericSeries DonchianHi;                      // 唐奇安通道上轨，延后1个Bar
   NumericSeries DonchianLo;                      // 唐奇安通道下轨，延后1个Bar
   NumericSeries fsDonchianHi;                    // 唐奇安通道上轨，延后1个Bar，长周期
   NumericSeries fsDonchianLo;                    // 唐奇安通道下轨，延后1个Bar，长周期
   Numeric ExitHighestPrice;               // 离市时判断需要的N周期最高价
   Numeric ExitLowestPrice;                // 离市时判断需要的N周期最低价
   Numeric myEntryPrice;                   // 开仓价格
   Numeric myExitPrice;                    // 平仓价格
   Bool SendOrderThisBar(False);                  // 当前Bar有过交易
       NumericSeries preEntryPrice(0);               // 前一次开仓的价格
       BoolSeries PreBreakoutFailure(false);        // 前一次突破是否失败
Begin
   If(BarStatus == 0)
   {
               preEntryPrice = InvalidNumeric;
               PreBreakoutFailure = false;
       }      
     
       MinPoint = MinMove*PriceScale;
   AvgTR = XAverage(TrueRange,ATRLength);
       N = AvgTR[1];      
   TotalEquity = Portfolio_CurrentCapital() + Portfolio_UsedMargin();
   TurtleUnits = (TotalEquity*RiskRatio/100) /(N * ContractUnit()*BigPointValue());
   TurtleUnits = IntPart(TurtleUnits); // 对小数取整

   DonchianHi = HighestFC(High[1],boLength);
   DonchianLo = LowestFC(Low[1],boLength);

       fsDonchianHi = HighestFC(High[1],fsLength);
   fsDonchianLo = LowestFC(Low[1],fsLength);
     
       ExitLowestPrice = LowestFC(Low[1],teLength);
       ExitHighestPrice = HighestFC(High[1],teLength);

       Commentary("N="+Text(N));
       Commentary("preEntryPrice="+Text(preEntryPrice));
       Commentary("PreBreakoutFailure="+IIFString(PreBreakoutFailure,"True","False"));
     
   // 当不使用过滤条件，或者使用过滤条件并且条件为PreBreakoutFailure为True进行后续操作
   If(MarketPosition == 0 && ((!LastProfitableTradeFilter) Or (PreBreakoutFailure)))
   {
       // 突破开仓
       If(High > DonchianHi && TurtleUnits >= 1)
       {
           // 开仓价格取突破上轨+一个价位和最高价之间的较小值，这样能更接近真实情况，并能尽量保证成交
           myEntryPrice = min(high,DonchianHi + MinPoint);
           myEntryPrice = IIF(myEntryPrice < Open, Open,myEntryPrice); // 大跳空的时候用开盘价代替
                       preEntryPrice = myEntryPrice;
           Buy(TurtleUnits,myEntryPrice);
                       SendOrderThisBar = True;
                       PreBreakoutFailure = False;
       }

       If(Low < DonchianLo && TurtleUnits >= 1)
       {
           // 开仓价格取突破下轨-一个价位和最低价之间的较大值，这样能更接近真实情况，并能尽量保证成交
           myEntryPrice = max(low,DonchianLo - MinPoint);
           myEntryPrice = IIF(myEntryPrice > Open, Open,myEntryPrice); // 大跳空的时候用开盘价代替
           preEntryPrice = myEntryPrice;
           SendOrderThisBar = True;
           SellShort(TurtleUnits,myEntryPrice);
                       SendOrderThisBar = True;
                       PreBreakoutFailure = False;
       }
   }

   // 长周期突破开仓 Failsafe Breakout point
   If(MarketPosition == 0)
   {
               Commentary("fsDonchianHi="+Text(fsDonchianHi));
       If(High > fsDonchianHi && TurtleUnits >= 1)
       {
           // 开仓价格取突破上轨+一个价位和最高价之间的较小值，这样能更接近真实情况，并能尽量保证成交
           myEntryPrice = min(high,fsDonchianHi + MinPoint);
           myEntryPrice = IIF(myEntryPrice < Open, Open,myEntryPrice); // 大跳空的时候用开盘价代替
                       preEntryPrice = myEntryPrice;
           Buy(TurtleUnits,myEntryPrice);
                       SendOrderThisBar = True;
                       PreBreakoutFailure = False;
       }

               Commentary("fsDonchianLo="+Text(fsDonchianLo));
       If(Low < fsDonchianLo && TurtleUnits >= 1)
       {
           // 开仓价格取突破下轨-一个价位和最低价之间的较大值，这样能更接近真实情况，并能尽量保证成交
           myEntryPrice = max(low,fsDonchianLo - MinPoint);
           myEntryPrice = IIF(myEntryPrice > Open, Open,myEntryPrice); // 大跳空的时候用开盘价代替
           preEntryPrice = myEntryPrice;
           SellShort(TurtleUnits,myEntryPrice);
                       SendOrderThisBar = True;
                       PreBreakoutFailure = False;
       }
   }

   If(MarketPosition == 1) // 有多仓的情况
   {      
               Commentary("ExitLowestPrice="+Text(ExitLowestPrice));
       If(Low < ExitLowestPrice)
       {
           myExitPrice = max(Low,ExitLowestPrice - MinPoint);
                       myExitPrice = IIF(myExitPrice > Open, Open,myExitPrice); // 大跳空的时候用开盘价代替
           Sell(0,myExitPrice);    // 数量用0的情况下将全部平仓
       }Else
       {
           If(preEntryPrice!=InvalidNumeric && TurtleUnits >= 1)
           {
               If(Open >= preEntryPrice + 0.5*N) // 如果开盘就超过设定的1/2N,则直接用开盘价增仓。
               {
                   myEntryPrice = Open;
                                       preEntryPrice = myEntryPrice;
                   Buy(TurtleUnits,myEntryPrice);
                                       SendOrderThisBar = True;
               }

               while(High >= preEntryPrice + 0.5*N) // 以最高价为标准，判断能进行几次增仓
               {
                   myEntryPrice = preEntryPrice + 0.5 * N;
                   preEntryPrice = myEntryPrice;
                   Buy(TurtleUnits,myEntryPrice);
                                       SendOrderThisBar = True;                                      
               }
           }
                     
           // 止损指令
                       If(Low <= preEntryPrice - 2 * N && SendOrderThisBar == false) // 加仓Bar不止损
                       {
                               myExitPrice = preEntryPrice - 2 * N;
                               Sell(0,myExitPrice); // 数量用0的情况下将全部平仓
                               PreBreakoutFailure = True;
                       }
       }
   }Else If(MarketPosition ==-1) // 有空仓的情况
   {
       // 求出持空仓时离市的条件比较值        
               Commentary("ExitHighestPrice="+Text(ExitHighestPrice));
       If(High > ExitHighestPrice)
       {
           myExitPrice = Min(High,ExitHighestPrice + MinPoint);
                       myExitPrice = IIF(myExitPrice < Open, Open,myExitPrice); // 大跳空的时候用开盘价代替
           BuyToCover(0,myExitPrice);    // 数量用0的情况下将全部平仓
       }Else
       {
           If(preEntryPrice!=InvalidNumeric && TurtleUnits >= 1)
           {
               If(Open <= preEntryPrice - 0.5*N) // 如果开盘就超过设定的1/2N,则直接用开盘价增仓。
               {
                   myEntryPrice = Open;
                                       preEntryPrice = myEntryPrice;
                   SellShort(TurtleUnits,myEntryPrice);
                                       SendOrderThisBar = True;
               }

               while(Low <= preEntryPrice - 0.5*N) // 以最低价为标准，判断能进行几次增仓
               {
                   myEntryPrice = preEntryPrice - 0.5 * N;
                   preEntryPrice = myEntryPrice;
                   SellShort(TurtleUnits,myEntryPrice);
                                       SendOrderThisBar = True;
               }
           }

           // 止损指令
                       If(High >= preEntryPrice + 2 * N &&SendOrderThisBar==false) // 加仓Bar不止损
                       {
                               myExitPrice = preEntryPrice + 2 * N;
                               BuyToCover(0,myExitPrice); // 数量用0的情况下将全部平仓
                               PreBreakoutFailure = True;
                       }
       }
   }
End